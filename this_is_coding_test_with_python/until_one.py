n, k = map(int, input().split())
count = 0

# 일반적인 방
'''
while n != 1:
    if n % k == 0:
        n /= k
        count += 1
    else:
        n -= 1
        count법 += 1

print(count)
'''

# 효율적인 방법
# 책에 나와있는 효율적인 방법은 밑의 주석에 설명해놓은대로지만 나는 몫연산을 하지않고 나머지 연산으로 풀어보았다.
while n >= k:
    remainder = n % k
    count += remainder
    n -= remainder
    
    count += 1
    n //= k

count += n - 1

print(count)
# 이것이 코딩테스트다 with Python 실전문제 3-5 문제 (1이 될 때 까지)
# P. 99

# 이것 또한 그리디 알고리즘을 활용한 문제이다.
# 단순하게 2 이상인 숫자인 k로 나누는 것이 1을 빼는 것보다 빠르기 때문에 n이 k의 배수일때 나누어 주고 아니면 배수가 될때까지 1을 빼주면 된다.
# 이 문제에서는 n의 값이 10만 이하이므로 일일이 1씩 빼주어도 되지만
# 만약에 n의 값이 100억 이상의 큰 수가 오면 좀 더 효율적으로 코드를 짤 필요가 있다.
# 아이디어는 동일하고 이 방법을 이용해서 더욱 효율적으로 코드를 짜는 방법은
# n을 k로 몫연산을 한 후 그 몫을 다시 k로 곱해 다음 타겟으로 잡는다.
# 그리고 카운트 변수에 n에 타겟을 빼준 값을 더해주고 n을 타겟으로 바꿔 주고 이것을 n이 k보다 작아질때까지 반복한다.
# 그러면 일일이 1을 빼는 것아니라 n이 k의 배수가 될때까지의 값을 한번에 빼버리는 것이기 때문에 훨쒼 효율적이다.
