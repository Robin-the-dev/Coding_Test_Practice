import sys
input = sys.stdin.readline

def solve():
    x = int(input().rstrip())
    
    # x는 30,000 이하의 숫자이기때문에 30,001개의 dp table을 만들어서 0으로 초기화 해줬다.
    dp_table = [0] * 30001

    for i in range(2, x + 1):
        # 1을 빼는 연산
        dp_table[i] = dp_table[i - 1] + 1

        # 2로 나누는 연산
        if i % 2 == 0:
            dp_table[i] = min(dp_table[i], dp_table[i // 2] + 1)
        
        # 3으로 나누는 연산
        if i % 3 == 0:
            dp_table[i] = min(dp_table[i], dp_table[i // 3] + 1)

        # 5로 나누는 연산
        if i % 5 == 0:
            dp_table[i] = min(dp_table[i], dp_table[i // 5] + 1)

    print(dp_table[x])

if __name__ == '__main__':
    solve()

# 이것이 코딩테스트다 with Python 실전문제 8-5 문제 (1로 만들기)
# P. 217

# 작은 문제에서 구한 답이 큰 문제에서도 사용할 수 있기 때문에
# 다이나믹 프로그래밍으로 접근 할 수 있는 문제이다.

# 다이나믹 프로그래밍이 무엇인줄만 알고 제일 유명한 피보나치 수열 문제 밖에
# 풀어보지 않았기때문에 점화식을 만드는 방법, 접근하는 방법자체가 헷갈려서
# 고민이 많았던 문제이다.
# 다이나믹 프로그래밍으로 풀 수 있다고 생각이되면 어떤식으로 접근할지 스스로
# 잘 생각해봐야겠다고 생각이 들었다.

# 탑다운, 보텀업 방식 두가지 다 사용이 가능하지만
# 보텀업 방식으로 하면 효율적이기도 하고 점화식 이해도 편해 보텀업으로 진행했다.
# 숫자를 입력받으면 1을 만들기 위한 최소의 횟수를 구하는 것이기 때문에
# 반복문은 2부터 시작하였고 dp table은 0으로 초기화 해주었다.

# 만약에 입력으로 6이 들어왔다면 2부터 시작해서 6까지 1을 빼거나 5, 3, 2로 나누는 연산은
# 이미 dp table안에 있다고 생각하고 진행하기 때문에 연산을 해서 나온 인덱스를 이용해서
# 1을 더한 값을 dp table안에 넣어 주면 된다. (왜냐하면 연산 횐수를 계산하기 때문)

# 다이나믹 프로그래밍 문제는 계속해서 풀어보는것이 중요할 것 같다.
