import sys
input = sys.stdin.readline

def solve():
    n = int(input().rstrip())
    k = list(map(int, input().rstrip().split()))

    dp_table = [0] * 101

    dp_table[0] = k[0]
    
    # 아래 부분을 max() 함수를 사용하지 않고 단순히 k[1]을 넣는 실수를 했다.
    dp_table[1] = max(k[0], k[1])

    for i in range(2, n):
        if dp_table[i - 2] + k[i] > dp_table[i - 1]:
            dp_table[i] = dp_table[i - 2] + k[i]
        else:
            dp_table[i] = dp_table[i - 1]

    print(dp_table[n - 1])

if __name__ == '__main__':
    solve()

# 이것이 코딩테스트다 with Python 실전문제 8-6 문제 (개미 전사)
# P. 220

# 다이나믹 프로그래밍 문제이다.
# 거의 다 제대로 풀었는데 한가지 실수를 했다.
# 위의 13번째줄에서 max() 함수를 사용하지 않고 그냥 k[1]을 넣었다.
# 이런식으로 하게되면 만약에 입력으로 3, 1, 1, 5가 들어오면
# 정답이 8이 아니라 6이 나오게 된다.

# 정답을 구하려면 3과 5를 선택해서 8이 나와야 되는데 6이 나온것이다.
# 나의 알고리즘은 i - 1과 i - 2에서 i를 더한 것 중에서 더 큰것을 집어넣는 방식으로
# 진행 되는데 그렇게 되면 첫번째 인덱스가 두번째 인덱스 보다 작아야지만 제대로 작동을 한다.
# 예를 들었던 3, 1, 1, 5에서 정답은 첫번째와 네번째가 선택이 되야하고 이런 경우도 있기
# 때문에 dp table의 두번째 인덱스는 입력의 첫번째와 두번째 인덱스의 수 중 더 큰것이
# 들어와야한다.

# 그리고 문제에서는 입력으로 받는 배열은 3이상이라고 되어있지만 max() 함수로 감쌌을때는
# 배열의 길이가 2이더라도 제대로 작동을 한다.
# 그러니까 이런 반례가 있는 경우를 꼭 염두에두고 코드에서 구현을 꼭 하자!!!
