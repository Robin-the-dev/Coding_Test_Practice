import sys
input = sys.stdin.readline

n = int(input())

meetings = [tuple(map(int, input().split())) for _ in range(n)]

meetings.sort(key = lambda t: (t[1], t[0]))

assigned_meetings = []
assigned_meetings.append(meetings[0])

for i in range(1, n):
    if assigned_meetings[-1][1] <= meetings[i][0]:
        assigned_meetings.append(meetings[i])

print(len(assigned_meetings))

# 백준 1931번 문제 (회의실 배정)
# https://www.acmicpc.net/problem/1931

# 정말 흔한 정렬 및 그리디 문제이다.
# 회의가 끝나는 시간으로 정렬해서 그리디 알고리즘을 사용해서 회의실에 회의를 
# 배정하면 된다는 방법을 찾아냈는데
# 계속 맞왜틀이 나와버렸다...

# 일단 간과한 부분이 두가지 있었다.
# 1. 회의가 끝나는 시간으로만 정렬을 하면 (5, 5) 와 (4, 5) 가 회의시간 입력에 있다고 했을때
#    시작시간의 기준으로는 정렬이 되어있지 않기때문에 (5, 5) 그리고 (4, 5)의 순서대로
#    정렬이 되기때문에 (5, 5)가 먼저 처리되고 (4, 5)의 시작시간이 (5, 5)의 끝나는 시간 보다
#    작기때문에 추가할 수 있음에도 불구하고 추가가 되지 않는다.
#    그렇기때문에 정렬을 할때 끝나는 시간으로 기준으로 정렬을 하고
#    끝나는 시간이 같고 시작시간이 다른 경우가 있어서 시작시간에 대해서도 정렬이 되어야한다.
#    위의 얘기대로 정렬을 하려면 코드에 있는 것처럼
#    lambda t: (t[1], t[2]) 와 같이 해주면 2차원 리스트도 일련의 과정대로 정렬을 해준다.
#    그러면 (5, 5)와 (4, 5)가 어떤 순서로 입력이 되든
#    항상 (4, 5) 그리고 (5, 5) 순서대로 정렬이 되어서 (4, 5)가 처리되고 (5, 5) 또한 처리된다.
#    문제에 이 부분을 알수있었던것이 
#    "한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다." 라고 적혀있다.
#    이것의 의미를 제대로 깨닫고 시작 시간 또한 정렬 할 수 있도록 생각을 하자!

# 2. 일단 접근 방법을 assigned_meetings라는 리스트를 만들어서 배정되는 회의를 이 리스트에 넣어#    이 리스트의 길이를 정답으로 하게끔하였다.
#    반복문을 시작하기 전에 정렬을 해두었기때문에 meetings의 첫번째가 무조건 배정이 되야해서
#    append 함수를 이용해 첫번째 미팅을 assigned_meetings안에 넣었다.
#    근데 처음에 코드를 쓸 때 반복문을 for meeting in meetings: 라고 해버렸다.
#    이렇게 하게되면 또 다시 첫 미팅 부터 반복을 시작하기 때문에
#    만약에 정렬된 미팅들의 첫번째가 (1, 1)이면 또 첫번째 미팅을 넣어버린다.
#    그래서 위의 고친 코드처럼 반복문을 첫번째 미팅을 제외하고 시작하게끔 해주거나
#    meetings 리스트의 첫번째를 popleft 함수를 써서 빼주고 반복문을 돌려야한다.

# 문제를 제대로 분석해서 제대로 코드를 짰다고 생각했지만
# 생각치 못한 부분이 나왔다.
# 같은 데이터를 특별한 이유가 없으면 중복해서 처리 하지 않게끔 하자!!!
